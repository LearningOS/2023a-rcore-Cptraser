## 实验功能

本次实验重写了ch3中的sys_write和sys_task_info，因为在分页机制启用的基础上原有代码不再可用。

上面两个系统调用涉及到用户空间中的内存使用，所以我设计了一个modify_byte_buffer函数，用于将src(启用分页的内核空间地址)中的len长度的内容拷贝到ptr(启用分页的内核用户地址)相同长度的物理内存中去。

本次实验还实现了sys_mmap和sys_mummap的匿名映射的内存申请和解绑系统调用。

这两个函数都需要对所映射的地址范围进行检查，其中有一个关键点在于框架内所有的区间都使用左闭右开的形式。而且在使用虚拟地址来找到对应的物理地址时，框架(mm::page_table::find_pte)在第0和第1层遇到没有下一层映射的情况时返回None，但是到第2层时会直接返回，所以我们在返回值不是None的情况下也要判断是否Vaild。



## 简答题

1. 标志位

    0. PTE_V: 页表项是否合法
    1. PTE_R: 页表项是否可读
    2. PTE_W: 页表项是否可写
    3. PTE_X: 页表项是否可取址
    4. PTE_U: U特权级是否可以访问
    5. PTE_G: 位表示这个映射是否对所有虚址空间有效
    6. PTE_A: 自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过
    7. PTE_D: 自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过

2. 缺页
    1. 缺页异常、无效页异常、写保护异常可能是缺页导致的。
    2. 重要寄存器
        1. sepc: S模式下的异常模式程序计数器(PC)寄存器
        2. sscratch: 用于异常处理的临时寄存器
        3. sstatus: S模式下的处理器状态寄存器
        4. scause: S模式下的异常原因寄存器
        5. stvec: S模式下的异常向量表入口地址寄存器
        6. stval: S模式下的异常向量寄存器（记录发生异常的虚拟地址）
    3. 可以减小系统运行时的内存消耗，减小运行时平均页表树大小，从而减小平均访问时间。
    4. 10G对应2,500,000页面×每个页面8B最后大概是200MB左右。
    5. Lazy策略建立在成功的地址申请上，我们可以在申请完成时不对物理页帧alloc，而是在使用的时候申请，也就是申请成功时只消耗200MB，在使用时不停扩张。缺页时向物理页帧管理器StackFrameAllocator申请内存。
    6. PTE_V置0，无法访问；PTE_A置0；PTE_D置1，表示页表已被修改。

3. 双页表与单页表
    1. 保存当前页表内容，加载保存在磁盘中的新页表内容，刷新TLB快表。
    2. 可以将内核页表基址的PTE中的PTE_D置1。
    3. 减小运行时开启的内存消耗，不使用时页表内容存储在磁盘中。
    4. 双页表需要在进程切换时更换页表；单页表则是在U/S切换时更换。


## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与以下各位就（与本次实验相关的）以下方面做过交流：组内成员：范天奇、余智超。且仅在实验编程题面的信息上做了交流，并没有涉及任何和编写代码有关的交流。

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：RISC-V 手册、rCore-Tutorial-Guide 2023 秋季学期、rCore-Tutorial-Book 第三版和相关线上课程视频。

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。